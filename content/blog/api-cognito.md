+++
title = "Minimal Setup to Secure API Gateway with Cognito using SAM"
date = 2024-03-31T00:00:00-00:00
draft = true
description = ""
tags = ["AWS", "API", "Security", "Serverless", "SAM"]
[[images]]
  src = "img/sam-yaml-anchors/title.png"
  alt = ""
  stretch = "stretchH"
+++

# Backstory
I am constantly creating APIs, whether they are for blog posts, playing around with new functionality or tools I want running. I've been creating these without any authentication in place. Doing this can pose a financial risk to my accounts if someone gets ahold of these endpoints. So I've decided to find a way to secure my APIs from the beginning using the bare minimum setup with Cognito.  In this post I will be setting up authentication to API Gateway with Cognito.

# What is Cognito?
AWS Cognito is a service provided by Amazon Web Services (AWS) that allows you to add authentication to your applications or services. It integrates natively with API Gateway to secure each endpoint.  

There are a several pieces that we need to secure our API using Cognito. Let's go over these:

1. **User Pool** - 
A Cognito user pool is the backbone to everything in Cognito. This is an [OpenID Connect identity provider](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) which contains the user directory to authenticate and authorize users.

2. **User Pool Domain** -
The user pool domain is used to give the authentication url a better name for us to use and give more confidence to our users.

3. **Resource Server** -
[An OAuth 2.0 API server](https://www.oauth.com/oauth2-servers/the-resource-server/) that validates that an access token contains the scopes that authorize the requested endpoint in the API.

4. **User Pool Client** -
User pool clients is a configuration within a user pool that interacts with your application that will be authenticating using Cognito whether that is going to be done from a UI or a backend service. 

# Authentication Flows
There are several authentication flows that you can use for your applications. [In this post from Auth0](https://auth0.com/docs/get-started/authentication-and-authorization-flow) you can get a better understanding about which flow is better for your use case.  
Since I am setting up very basic authentication to be able to test with Postman I will be using the [Client Credentials Flow (CCF)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) to allow us to authenticate our requests by sending a *client id* and a *client secret* in exchange for an *access token* in the form of a [JSON Web Token (JWT)](https://jwt.io/introduction). The CCF is recommended when working with Machine-to-Machine (M2M) communication like CLIs, APIs, etc.

# Setting it all up with SAM
Since I create many APis, I really don't want to create a Cognito User Pool per API that I create, so to simplify my authentication architecture I will be having a single Auth Stack that will contain the *User Pool* and the *User Pool Domain* definition, the user pool data will be set in an SSM parameter that will be able to be consumed by other stacks. Below is a picture that shows how this would look.

![CloudFormation Stack Architecture](/img/api-cognito/stack-architecture.png)

As shown in the image above, we have the auth stack where we define our Cognito User Pool and User Pool Domain. Then each application that wants to authenticate using this user pool will create it's own Resource Server and User Pool Client.

Now let's see how each of these pieces are setup using SAM

## Auth Stack
Here we are going to define the resources that are going to be able to be consumed by other APIs to authenticate.  
You can find my full setup for this stack [in this GitHub repository](https://github.com/andmoredev/cognito-auth)

### 1. User Pool
The User Pool requires minimal setup when doing CCF, you simply need to define the resource with no configuration. You are able to add more restrictions and configuration but as mentioned before, we are trying to keep it to the bare minimum here.
```yaml
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
```

### 2. User Pool Domain
The user pool domain is used to give the authentication url a better name for us to use and give more confidence to our users. In my setup I will be using `andmoredev` as my domain which makes our sign in url look like `https://andmoredev.auth.us-east-1.amazoncognito.com/login`. You can setup up your own custom domain that does not include anything generated by AWS in the URL by setting up the `CustomDomainConfig`.
```yaml
  CognitoUserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      UserPoolId: !Ref CognitoUserPool
      Domain: andmoredev
```

We need to make sure other stacks can get access to the User Pool Id and ARN to be able to create the necessary resources. To do this we are going to use SSM Paramters.
```yaml
  CognitoUserPoolIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /${AWS::StackName}/CognitoUserPoolId
      Type: String
      Value: !Ref CognitoUserPool

  CognitoUserPoolArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /${AWS::StackName}/CognitoUserPoolArn
      Type: String
      Value: !GetAtt CognitoUserPool.Arn
```

Now we can add authentication to a separate stack using the same user pool.

## API Stack
Now let's use the user pool for one of our APIs, for this example I will be setting up authentication to an API I had previously created. [Here is the GitHub repository](https://github.com/andmoredev/layerless-esbuild-lambda) with the added authentication.
### 1. Consuming Auth Stack resources
Since the auth stack defined SSM parameters for the data we need to setup our resource server and client, all we need to do is consume these int he parameters section of the SAM template as shown below.
```yaml
Parameters:
  CognitoUserPoolId:
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: '/andmoredev-auth/CognitoUserPoolId'

  CognitoUserPoolArn:
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: '/andmoredev-auth/CognitoUserPoolArn'
```

### 2. Resource Server
We are creating a simple resource server with one scope that will be used to give access to any endpoint in our APIs. I will not go into more details on more advanced scope design in this post.
```yaml
  LayerlessESBuildResourceServer:
    Type: AWS::Cognito::UserPoolResourceServer
    Properties:
      UserPoolId: !Ref CognitoUserPoolId
      Identifier: layerless-esbuild
      Name: Layerless ESBuild
      Scopes:
        - ScopeName: api
          ScopeDescription: Allow api access
```

### 3. User Pool Client
```yaml
  CognitoTestAutomationClient:
    Type: AWS::Cognito::UserPoolClient
    DependsOn:
      - PostmanResourceServer
    Properties:
      UserPoolId: !Ref CognitoUserPoolId
      GenerateSecret: true
      AllowedOAuthFlows:
        - client_credentials
      AllowedOAuthScopes:
        - layerless-esbuild/api
```

We need to explicitly tell it to generate a secret by settin gthe *GenerateSecret* attribute to true, this is normal when working with a client credentials flow, but is not recommended when creating a client that will be used by a frontend. We are only going to allow this client to authenticate using the `client_credentials` OAuth flow and we need to provide it access to the scope we setup for our resource server. I've seen deployment scenarios where the resource server gets deployed after the client and we get an error saying the scope does not exist, this is the reason I am explicitly adding the `DependsOn` for this resource.

### 4. Hooking it all up to API Gateway
To tell our API Gateway to authenticate using our new Cognito User Pool we need to add teh *Auth* property, it will look something like this.
```yaml
  Auth:
    DefaultAuthorizer: ClientCognitoAuthorizer
    Authorizers:
      ClientCognitoAuthorizer:
        UserPoolArn: !Ref CognitoUserPoolArn
        AuthorizationScopes:
          - layerless-esbuild/echo
```

# Testing it using Postman

