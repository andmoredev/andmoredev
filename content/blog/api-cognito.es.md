+++
title = "Minimal Setup to Secure API Gateway with Cognito using SAM"
date = 2024-03-31T00:00:00-00:00
draft = false
description = ""
tags = ["AWS", "API", "Security", "Serverless", "SAM"]
[[images]]
  src = "img/api-cognito/title-es.png"
  alt = ""
  stretch = "stretchH"
+++

# Backstory
I am constantly creating APIs, whether they are for blog posts, playing around with new functionality or tools that I use daily. I've been creating these without any authentication in place. Doing this can pose a financial risk to my accounts if someone gets ahold of these endpoints. So I've decided to secure my APIs from the beginning using the bare minimum setup with Cognito.  In this post I will be setting up authentication to API Gateway with Cognito.

# What is Cognito?
AWS Cognito is a service provided by Amazon Web Services (AWS) that allows you to add authentication to your applications or services. It integrates natively with API Gateway to secure each endpoint.  

There are a several pieces that we need to secure our API using Cognito. Let's go over these:

1. **User Pool** - 
A Cognito user pool is the backbone to everything in Cognito. This is an [OpenID Connect identity provider](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol) which contains the user directory to authenticate and authorize users.

2. **User Pool Domain** -
The user pool domain is used to give the authentication url a better name for us to use and give more confidence to our users.

3. **Resource Server** -
[An OAuth 2.0 API server](https://www.oauth.com/oauth2-servers/the-resource-server/) that validates that an access token contains the scopes that authorize the requested endpoint in the API.

4. **User Pool Client** -
User pool clients is a configuration within a user pool that interacts with your application that will be authenticating using Cognito whether that is going to be done from a UI or a backend service. 

# Authentication Flows
There are several authentication flows that you can use for your applications. [In this post from Auth0](https://auth0.com/docs/get-started/authentication-and-authorization-flow) you can get a better understanding about which flow is better for your use case.  
Since I am setting up very basic authentication to be able to test with Postman I will be using the [Client Credentials Flow (CCF)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-credentials-flow) to allow us to authenticate our requests by sending a *client id* and a *client secret* in exchange for an *access token* in the form of a [JSON Web Token (JWT)](https://jwt.io/introduction). The CCF is recommended when working with Machine-to-Machine (M2M) communication like CLIs, APIs, etc.

# Setting it all up with SAM
Since I create many APis, I really don't want to create a Cognito User Pool per API that I create, so to simplify my authentication architecture I will be having a single Auth Stack that will contain the *User Pool* and the *User Pool Domain* definition, the user pool data will be set in an SSM parameter that will be able to be consumed by other stacks. Below is a picture that shows how this would look.

![CloudFormation Stack Architecture](/img/api-cognito/stack-architecture.png)

As shown in the image above, we have the auth stack where we define our Cognito User Pool and User Pool Domain. Then each application that wants to authenticate using this user pool will create it's own Resource Server and User Pool Client.

Now let's see how each of these pieces are setup using SAM

## Auth Stack
Here we are going to define the resources that are going to be able to be consumed by other APIs to authenticate.  
You can find my full setup for this stack [in this GitHub repository](https://github.com/andmoredev/cognito-auth)

### 1. User Pool
The User Pool requires minimal setup when doing CCF, you simply need to define the resource with no configuration. You are able to add more restrictions and configuration but as mentioned before, we are trying to keep it to the bare minimum here.
```yaml
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
```

### 2. User Pool Domain
The user pool domain is used to give the authentication url a better name for us to use and give more confidence to our users. In my setup I will be using `andmoredev` as my domain which makes our sign in url look like `https://andmoredev.auth.us-east-1.amazoncognito.com/login`. You can setup up your own custom domain that does not include anything generated by AWS in the URL by setting up the `CustomDomainConfig`.
```yaml
  CognitoUserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      UserPoolId: !Ref CognitoUserPool
      Domain: andmoredev
```

We need to make sure other stacks can get access to the User Pool Id and ARN to be able to create the necessary resources. To do this we are going to use SSM Paramters.
```yaml
  CognitoUserPoolIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /${AWS::StackName}/CognitoUserPoolId
      Type: String
      Value: !Ref CognitoUserPool

  CognitoUserPoolArnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /${AWS::StackName}/CognitoUserPoolArn
      Type: String
      Value: !GetAtt CognitoUserPool.Arn
```

Now we can add authentication to a separate stack using the same user pool.

## API Stack
Now let's use the user pool for one of our APIs, for this example I will be setting up authentication to an API I had previously created. [Here is the GitHub repository](https://github.com/andmoredev/layerless-esbuild-lambda) with the added authentication.
### 1. Consuming Auth Stack resources
Since the auth stack defined SSM parameters for the data we need to setup our resource server and client, all we need to do is consume these int he parameters section of the SAM template as shown below.
```yaml
Parameters:
  CognitoUserPoolId:
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: '/andmoredev-auth/CognitoUserPoolId'

  CognitoUserPoolArn:
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: '/andmoredev-auth/CognitoUserPoolArn'
```

### 2. Resource Server
We are creating a simple resource server with one scope that will be used to give access to any endpoint in our APIs. I will not go into more details on more advanced scope design in this post.
```yaml
  LayerlessESBuildResourceServer:
    Type: AWS::Cognito::UserPoolResourceServer
    Properties:
      UserPoolId: !Ref CognitoUserPoolId
      Identifier: layerless-esbuild
      Name: Layerless ESBuild
      Scopes:
        - ScopeName: api
          ScopeDescription: Allow api access
```

### 3. User Pool Client
```yaml
  CognitoTestAutomationClient:
    Type: AWS::Cognito::UserPoolClient
    DependsOn:
      - PostmanResourceServer
    Properties:
      UserPoolId: !Ref CognitoUserPoolId
      GenerateSecret: true
      AllowedOAuthFlows:
        - client_credentials
      AllowedOAuthScopes:
        - layerless-esbuild/api
```

We need to explicitly tell it to generate a secret by settin gthe *GenerateSecret* attribute to true, this is normal when working with a client credentials flow, but is not recommended when creating a client that will be used by a frontend. We are only going to allow this client to authenticate using the `client_credentials` OAuth flow and we need to provide it access to the scope we setup for our resource server. I've seen deployment scenarios where the resource server gets deployed after the client and we get an error saying the scope does not exist, this is the reason I am explicitly adding the `DependsOn` for this resource.

### 4. Hooking it all up to API Gateway
To tell our API Gateway to authenticate using our new Cognito User Pool we need to add teh *Auth* property, it will look something like this.
```yaml
  Auth:
    DefaultAuthorizer: ClientCognitoAuthorizer
    Authorizers:
      ClientCognitoAuthorizer:
        UserPoolArn: !Ref CognitoUserPoolArn
        AuthorizationScopes:
          - layerless-esbuild/echo
```

# Testing it using Postman

## 1. Grab authentication data
To be able to test this we need to go into the console and grab the Client Id and Client Secret that was generated. These are located in the Cognito service by selecting your user pool and in the *App integration* section in the bottom you will see your new app client, once you open it you will something like the image below, you can copy the Client ID and Client secret from here to be used for your requests.  

![AWS Console showing an application client in Cognito where we can grab the client id and secret](/img/api-cognito/cognito-client-keys.png)

> Please handle these values with care, if compromised someone could gain access to your APIs and do malicious things.

## 2. Run un-authenticated request
To verify our API is secure we will first run an unauthenticated request. To do this we will call our endpoint without setting anything for the authentication, when we send this request we should get a 401 - Unauthorized response as shown below.  

![Postman request showing an unauthorized resopnse](/img/api-cognito/postman-unauthorized.png)

## 3. Set authentication data in Postman
With the values we will now use a new [Postman feature called **Vaults**](https://learning.postman.com/docs/sending-requests/postman-vault/postman-vault-secrets/) that allow us to securely store sensitive data. To do this we will go into the Vault section in the bottom of the window and add our secrets as shown in the picture below.  

![Postman Vault window showing an item for clientId and clientSecret and their masked values](/img/api-cognito/postman-vault.png)

## 4. Setup request authentication
Now back in the Postman request we can set the Authorization configuration. We need to setup a few things here.  
* Grant type - This will have a value of *Client Credentials*
* Access Token URL - The value for your specific user pool will vary depending on your configured user pool domain. It will look something like this `https://[your-domain].auth.us-east-1.amazoncognito.com/oauth2/token`
* Client ID - We will grab this from the vault by setting a value of `{{vault:clientId}}`
* Client Secret - Also from the vault with a value of `{{value:clientSecert}}`
* Scope - This will be based on what was set on the resource server. From our example it will be `layerless-esbuild/echo`.

![Postman Authorization Configuration with all the values mentioned above filled in](/img/api-cognito/postman-authorization-configuration.png)

## 5. Get a token
We can now get a new access token by going to the bottom of the Authorization section and pressing the *Get New Access Token* button. If successful you will receive a prompt where you can click a button that says *Use Token*. By pressing that button you will get the value presented in the Access Token and it will be used in the *Authorization* header of your request.

If we send the request now we will get a successful response.
![Postman showing a successful request](/img/api-cognito/postman-success.png)

# Wrap Up

